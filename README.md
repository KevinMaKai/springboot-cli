# springboot-cli
springboot脚手架，包括springboot、ibatis、dubbo等等整合

1、模块精简,且模块之间的引用关系是串行,不能出现回环引用
                  父模块                       （1.引用srpingboot    2.提供build指令）
                  ||
                  web模块                    （ 1.引用facade模块   2.提供子模块build指令）
                  ||
                  facade模块                （1.引用service模块）
                  ||
                  service模块               （1.引用common模块  2.所有核心代码均在这里书写）
                  ||
                  common模块             （1.引用export模块，该模块是核心模块其负责引用所有依赖的业务模块）
                  ||
                  export模块                  （该模块独立存在，不需要有父模块，而且该模块的编译级别是1.7，不同于其他模块）
2、部门统一的common模块不再出现在父模块，而将其放到common模块,这样将来排包的时候统一在common模块即可，也避免了不必要的引入。

3、删减不必要的属性设置，不需要的属性就不要写了。

4、抽包和build的关系，jdos平台默认是会执行父模块的build指令，从而触发reactor机制，但是他会联动子模块(web)的build指令，因而父模块的build指令主要是负责编译级别、资源文件位置等，而子模块(web)的build是个性化的内容例如根据环境找到profile、检查配置等。
5、使用springboot并不仅仅是技术栈的更迭，更是一种思想的改变：
   之前我们将dao,rpc,manager等模块抽象出来，但是当代码量多了，需要技改的时候却发现很难快速定位这个功能到底涉及哪些类。今后的做法是将这些全部内置到一个一个的业务模块中，这样的做的好处是方便将来抽离代码，也就是比如A功能下涉及的service,dto,rpc,dao等全部在一个package中。而什么时候这些业务可以抽离出去呢，这个就是问一个微服务到底是什么标准，假如我们规定2万行代码就算是一个微服务的最高限制，超过两万行代码就必须要抽离，那么当某个项目超过2万行之后，就在里边找合适的业务功能，然后直接移动走就可以了。
6、如何看一个项目当前选择了那个版本的jar包呢?
  有的时候平台要求某个jar包版本过低或者或者冲突，怎么在IDEA快速的看呢，其实就看最终抽包用的那个模块就好了，假如最终用的是web模块，就利用maven healp插件检测出最终选定的jar包版本，这里显示的是什么版本就是Maven打包选定的版本。而如果想要排包，其实只要在common模块中排除相关的包即可，记住一定是要在common模块中排包，就是谁引用的他，就在那个层排除，切记不要跨层排包。
  总结两句话：在common模块中排除冲突包，在web模块中查看最终选定的是什么版本。

